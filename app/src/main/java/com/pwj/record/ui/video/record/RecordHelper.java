package com.pwj.record.ui.video.record;

/**
 * @Author: pwj
 * @Date: 2020/12/16 9:44
 * @FileName: RecordHelper
 * @Description: description
 * @param audioSource ：录音源
 * 这里选择使用麦克风：MediaRecorder.AudioSource.MIC
 * @param sampleRateInHz： 采样率
 * @param channelConfig：声道数
 * @param audioFormat： 采样位数.
 * See {@link AudioFormat#ENCODING_PCM_8BIT}, {@link AudioFormat#ENCODING_PCM_16BIT},
 * and {@link AudioFormat#ENCODING_PCM_FLOAT}.
 * @param bufferSizeInBytes： 音频录制的缓冲区大小
 * See {@link #getMinBufferSize(int, int, int)}
 * <p>
 * 获取AudioRecord所需的最小缓冲区大小
 * @param sampleRateInHz： 采样率
 * @param channelConfig：声道数
 * @param audioFormat： 采样位数.
 * <p>
 * 获取AudioRecord当前的录音状态
 * @param audioSource ：录音源
 * 这里选择使用麦克风：MediaRecorder.AudioSource.MIC
 * @param sampleRateInHz： 采样率
 * @param channelConfig：声道数
 * @param audioFormat： 采样位数.
 * See {@link AudioFormat#ENCODING_PCM_8BIT}, {@link AudioFormat#ENCODING_PCM_16BIT},
 * and {@link AudioFormat#ENCODING_PCM_FLOAT}.
 * @param bufferSizeInBytes： 音频录制的缓冲区大小
 * See {@link #getMinBufferSize(int, int, int)}
 * <p>
 * 获取AudioRecord所需的最小缓冲区大小
 * @param sampleRateInHz： 采样率
 * @param channelConfig：声道数
 * @param audioFormat： 采样位数.
 * <p>
 * 获取AudioRecord当前的录音状态
 * @param audioSource ：录音源
 * 这里选择使用麦克风：MediaRecorder.AudioSource.MIC
 * @param sampleRateInHz： 采样率
 * @param channelConfig：声道数
 * @param audioFormat： 采样位数.
 * See {@link AudioFormat#ENCODING_PCM_8BIT}, {@link AudioFormat#ENCODING_PCM_16BIT},
 * and {@link AudioFormat#ENCODING_PCM_FLOAT}.
 * @param bufferSizeInBytes： 音频录制的缓冲区大小
 * See {@link #getMinBufferSize(int, int, int)}
 * <p>
 * 获取AudioRecord所需的最小缓冲区大小
 * @param sampleRateInHz： 采样率
 * @param channelConfig：声道数
 * @param audioFormat： 采样位数.
 * <p>
 * 获取AudioRecord当前的录音状态
 * @param audioSource ：录音源
 * 这里选择使用麦克风：MediaRecorder.AudioSource.MIC
 * @param sampleRateInHz： 采样率
 * @param channelConfig：声道数
 * @param audioFormat： 采样位数.
 * See {@link AudioFormat#ENCODING_PCM_8BIT}, {@link AudioFormat#ENCODING_PCM_16BIT},
 * and {@link AudioFormat#ENCODING_PCM_FLOAT}.
 * @param bufferSizeInBytes： 音频录制的缓冲区大小
 * See {@link #getMinBufferSize(int, int, int)}
 * <p>
 * 获取AudioRecord所需的最小缓冲区大小
 * @param sampleRateInHz： 采样率
 * @param channelConfig：声道数
 * @param audioFormat： 采样位数.
 * <p>
 * 获取AudioRecord当前的录音状态
 * @param audioSource ：录音源
 * 这里选择使用麦克风：MediaRecorder.AudioSource.MIC
 * @param sampleRateInHz： 采样率
 * @param channelConfig：声道数
 * @param audioFormat： 采样位数.
 * See {@link AudioFormat#ENCODING_PCM_8BIT}, {@link AudioFormat#ENCODING_PCM_16BIT},
 * and {@link AudioFormat#ENCODING_PCM_FLOAT}.
 * @param bufferSizeInBytes： 音频录制的缓冲区大小
 * See {@link #getMinBufferSize(int, int, int)}
 * <p>
 * 获取AudioRecord所需的最小缓冲区大小
 * @param sampleRateInHz： 采样率
 * @param channelConfig：声道数
 * @param audioFormat： 采样位数.
 * <p>
 * 获取AudioRecord当前的录音状态
 * @param audioSource ：录音源
 * 这里选择使用麦克风：MediaRecorder.AudioSource.MIC
 * @param sampleRateInHz： 采样率
 * @param channelConfig：声道数
 * @param audioFormat： 采样位数.
 * See {@link AudioFormat#ENCODING_PCM_8BIT}, {@link AudioFormat#ENCODING_PCM_16BIT},
 * and {@link AudioFormat#ENCODING_PCM_FLOAT}.
 * @param bufferSizeInBytes： 音频录制的缓冲区大小
 * See {@link #getMinBufferSize(int, int, int)}
 * <p>
 * 获取AudioRecord所需的最小缓冲区大小
 * @param sampleRateInHz： 采样率
 * @param channelConfig：声道数
 * @param audioFormat： 采样位数.
 * <p>
 * 获取AudioRecord当前的录音状态
 * @param audioSource ：录音源
 * 这里选择使用麦克风：MediaRecorder.AudioSource.MIC
 * @param sampleRateInHz： 采样率
 * @param channelConfig：声道数
 * @param audioFormat： 采样位数.
 * See {@link AudioFormat#ENCODING_PCM_8BIT}, {@link AudioFormat#ENCODING_PCM_16BIT},
 * and {@link AudioFormat#ENCODING_PCM_FLOAT}.
 * @param bufferSizeInBytes： 音频录制的缓冲区大小
 * See {@link #getMinBufferSize(int, int, int)}
 * <p>
 * 获取AudioRecord所需的最小缓冲区大小
 * @param sampleRateInHz： 采样率
 * @param channelConfig：声道数
 * @param audioFormat： 采样位数.
 * <p>
 * 获取AudioRecord当前的录音状态
 * @param audioSource ：录音源
 * 这里选择使用麦克风：MediaRecorder.AudioSource.MIC
 * @param sampleRateInHz： 采样率
 * @param channelConfig：声道数
 * @param audioFormat： 采样位数.
 * See {@link AudioFormat#ENCODING_PCM_8BIT}, {@link AudioFormat#ENCODING_PCM_16BIT},
 * and {@link AudioFormat#ENCODING_PCM_FLOAT}.
 * @param bufferSizeInBytes： 音频录制的缓冲区大小
 * See {@link #getMinBufferSize(int, int, int)}
 * <p>
 * 获取AudioRecord所需的最小缓冲区大小
 * @param sampleRateInHz： 采样率
 * @param channelConfig：声道数
 * @param audioFormat： 采样位数.
 * <p>
 * 获取AudioRecord当前的录音状态
 * @param audioSource ：录音源
 * 这里选择使用麦克风：MediaRecorder.AudioSource.MIC
 * @param sampleRateInHz： 采样率
 * @param channelConfig：声道数
 * @param audioFormat： 采样位数.
 * See {@link AudioFormat#ENCODING_PCM_8BIT}, {@link AudioFormat#ENCODING_PCM_16BIT},
 * and {@link AudioFormat#ENCODING_PCM_FLOAT}.
 * @param bufferSizeInBytes： 音频录制的缓冲区大小
 * See {@link #getMinBufferSize(int, int, int)}
 * <p>
 * 获取AudioRecord所需的最小缓冲区大小
 * @param sampleRateInHz： 采样率
 * @param channelConfig：声道数
 * @param audioFormat： 采样位数.
 * <p>
 * 获取AudioRecord当前的录音状态
 * @param audioSource ：录音源
 * 这里选择使用麦克风：MediaRecorder.AudioSource.MIC
 * @param sampleRateInHz： 采样率
 * @param channelConfig：声道数
 * @param audioFormat： 采样位数.
 * See {@link AudioFormat#ENCODING_PCM_8BIT}, {@link AudioFormat#ENCODING_PCM_16BIT},
 * and {@link AudioFormat#ENCODING_PCM_FLOAT}.
 * @param bufferSizeInBytes： 音频录制的缓冲区大小
 * See {@link #getMinBufferSize(int, int, int)}
 * <p>
 * 获取AudioRecord所需的最小缓冲区大小
 * @param sampleRateInHz： 采样率
 * @param channelConfig：声道数
 * @param audioFormat： 采样位数.
 * <p>
 * 获取AudioRecord当前的录音状态
 * @param audioSource ：录音源
 * 这里选择使用麦克风：MediaRecorder.AudioSource.MIC
 * @param sampleRateInHz： 采样率
 * @param channelConfig：声道数
 * @param audioFormat： 采样位数.
 * See {@link AudioFormat#ENCODING_PCM_8BIT}, {@link AudioFormat#ENCODING_PCM_16BIT},
 * and {@link AudioFormat#ENCODING_PCM_FLOAT}.
 * @param bufferSizeInBytes： 音频录制的缓冲区大小
 * See {@link #getMinBufferSize(int, int, int)}
 * <p>
 * 获取AudioRecord所需的最小缓冲区大小
 * @param sampleRateInHz： 采样率
 * @param channelConfig：声道数
 * @param audioFormat： 采样位数.
 * <p>
 * 获取AudioRecord当前的录音状态
 * @param audioSource ：录音源
 * 这里选择使用麦克风：MediaRecorder.AudioSource.MIC
 * @param sampleRateInHz： 采样率
 * @param channelConfig：声道数
 * @param audioFormat： 采样位数.
 * See {@link AudioFormat#ENCODING_PCM_8BIT}, {@link AudioFormat#ENCODING_PCM_16BIT},
 * and {@link AudioFormat#ENCODING_PCM_FLOAT}.
 * @param bufferSizeInBytes： 音频录制的缓冲区大小
 * See {@link #getMinBufferSize(int, int, int)}
 * <p>
 * 获取AudioRecord所需的最小缓冲区大小
 * @param sampleRateInHz： 采样率
 * @param channelConfig：声道数
 * @param audioFormat： 采样位数.
 * <p>
 * 获取AudioRecord当前的录音状态
 * @param audioSource ：录音源
 * 这里选择使用麦克风：MediaRecorder.AudioSource.MIC
 * @param sampleRateInHz： 采样率
 * @param channelConfig：声道数
 * @param audioFormat： 采样位数.
 * See {@link AudioFormat#ENCODING_PCM_8BIT}, {@link AudioFormat#ENCODING_PCM_16BIT},
 * and {@link AudioFormat#ENCODING_PCM_FLOAT}.
 * @param bufferSizeInBytes： 音频录制的缓冲区大小
 * See {@link #getMinBufferSize(int, int, int)}
 * <p>
 * 获取AudioRecord所需的最小缓冲区大小
 * @param sampleRateInHz： 采样率
 * @param channelConfig：声道数
 * @param audioFormat： 采样位数.
 * <p>
 * 获取AudioRecord当前的录音状态
 * @param audioSource ：录音源
 * 这里选择使用麦克风：MediaRecorder.AudioSource.MIC
 * @param sampleRateInHz： 采样率
 * @param channelConfig：声道数
 * @param audioFormat： 采样位数.
 * See {@link AudioFormat#ENCODING_PCM_8BIT}, {@link AudioFormat#ENCODING_PCM_16BIT},
 * and {@link AudioFormat#ENCODING_PCM_FLOAT}.
 * @param bufferSizeInBytes： 音频录制的缓冲区大小
 * See {@link #getMinBufferSize(int, int, int)}
 * <p>
 * 获取AudioRecord所需的最小缓冲区大小
 * @param sampleRateInHz： 采样率
 * @param channelConfig：声道数
 * @param audioFormat： 采样位数.
 * <p>
 * 获取AudioRecord当前的录音状态
 * @param audioSource ：录音源
 * 这里选择使用麦克风：MediaRecorder.AudioSource.MIC
 * @param sampleRateInHz： 采样率
 * @param channelConfig：声道数
 * @param audioFormat： 采样位数.
 * See {@link AudioFormat#ENCODING_PCM_8BIT}, {@link AudioFormat#ENCODING_PCM_16BIT},
 * and {@link AudioFormat#ENCODING_PCM_FLOAT}.
 * @param bufferSizeInBytes： 音频录制的缓冲区大小
 * See {@link #getMinBufferSize(int, int, int)}
 * <p>
 * 获取AudioRecord所需的最小缓冲区大小
 * @param sampleRateInHz： 采样率
 * @param channelConfig：声道数
 * @param audioFormat： 采样位数.
 * <p>
 * 获取AudioRecord当前的录音状态
 * @param audioSource ：录音源
 * 这里选择使用麦克风：MediaRecorder.AudioSource.MIC
 * @param sampleRateInHz： 采样率
 * @param channelConfig：声道数
 * @param audioFormat： 采样位数.
 * See {@link AudioFormat#ENCODING_PCM_8BIT}, {@link AudioFormat#ENCODING_PCM_16BIT},
 * and {@link AudioFormat#ENCODING_PCM_FLOAT}.
 * @param bufferSizeInBytes： 音频录制的缓冲区大小
 * See {@link #getMinBufferSize(int, int, int)}
 * <p>
 * 获取AudioRecord所需的最小缓冲区大小
 * @param sampleRateInHz： 采样率
 * @param channelConfig：声道数
 * @param audioFormat： 采样位数.
 * <p>
 * 获取AudioRecord当前的录音状态
 * @param audioSource ：录音源
 * 这里选择使用麦克风：MediaRecorder.AudioSource.MIC
 * @param sampleRateInHz： 采样率
 * @param channelConfig：声道数
 * @param audioFormat： 采样位数.
 * See {@link AudioFormat#ENCODING_PCM_8BIT}, {@link AudioFormat#ENCODING_PCM_16BIT},
 * and {@link AudioFormat#ENCODING_PCM_FLOAT}.
 * @param bufferSizeInBytes： 音频录制的缓冲区大小
 * See {@link #getMinBufferSize(int, int, int)}
 * <p>
 * 获取AudioRecord所需的最小缓冲区大小
 * @param sampleRateInHz： 采样率
 * @param channelConfig：声道数
 * @param audioFormat： 采样位数.
 * <p>
 * 获取AudioRecord当前的录音状态
 * @param audioSource ：录音源
 * 这里选择使用麦克风：MediaRecorder.AudioSource.MIC
 * @param sampleRateInHz： 采样率
 * @param channelConfig：声道数
 * @param audioFormat： 采样位数.
 * See {@link AudioFormat#ENCODING_PCM_8BIT}, {@link AudioFormat#ENCODING_PCM_16BIT},
 * and {@link AudioFormat#ENCODING_PCM_FLOAT}.
 * @param bufferSizeInBytes： 音频录制的缓冲区大小
 * See {@link #getMinBufferSize(int, int, int)}
 * <p>
 * 获取AudioRecord所需的最小缓冲区大小
 * @param sampleRateInHz： 采样率
 * @param channelConfig：声道数
 * @param audioFormat： 采样位数.
 * <p>
 * 获取AudioRecord当前的录音状态
 * @param audioSource ：录音源
 * 这里选择使用麦克风：MediaRecorder.AudioSource.MIC
 * @param sampleRateInHz： 采样率
 * @param channelConfig：声道数
 * @param audioFormat： 采样位数.
 * See {@link AudioFormat#ENCODING_PCM_8BIT}, {@link AudioFormat#ENCODING_PCM_16BIT},
 * and {@link AudioFormat#ENCODING_PCM_FLOAT}.
 * @param bufferSizeInBytes： 音频录制的缓冲区大小
 * See {@link #getMinBufferSize(int, int, int)}
 * <p>
 * 获取AudioRecord所需的最小缓冲区大小
 * @param sampleRateInHz： 采样率
 * @param channelConfig：声道数
 * @param audioFormat： 采样位数.
 * <p>
 * 获取AudioRecord当前的录音状态
 * @param audioSource ：录音源
 * 这里选择使用麦克风：MediaRecorder.AudioSource.MIC
 * @param sampleRateInHz： 采样率
 * @param channelConfig：声道数
 * @param audioFormat： 采样位数.
 * See {@link AudioFormat#ENCODING_PCM_8BIT}, {@link AudioFormat#ENCODING_PCM_16BIT},
 * and {@link AudioFormat#ENCODING_PCM_FLOAT}.
 * @param bufferSizeInBytes： 音频录制的缓冲区大小
 * See {@link #getMinBufferSize(int, int, int)}
 * <p>
 * 获取AudioRecord所需的最小缓冲区大小
 * @param sampleRateInHz： 采样率
 * @param channelConfig：声道数
 * @param audioFormat： 采样位数.
 * <p>
 * 获取AudioRecord当前的录音状态
 * @param audioSource ：录音源
 * 这里选择使用麦克风：MediaRecorder.AudioSource.MIC
 * @param sampleRateInHz： 采样率
 * @param channelConfig：声道数
 * @param audioFormat： 采样位数.
 * See {@link AudioFormat#ENCODING_PCM_8BIT}, {@link AudioFormat#ENCODING_PCM_16BIT},
 * and {@link AudioFormat#ENCODING_PCM_FLOAT}.
 * @param bufferSizeInBytes： 音频录制的缓冲区大小
 * See {@link #getMinBufferSize(int, int, int)}
 * <p>
 * 获取AudioRecord所需的最小缓冲区大小
 * @param sampleRateInHz： 采样率
 * @param channelConfig：声道数
 * @param audioFormat： 采样位数.
 * <p>
 * 获取AudioRecord当前的录音状态
 * @param audioSource ：录音源
 * 这里选择使用麦克风：MediaRecorder.AudioSource.MIC
 * @param sampleRateInHz： 采样率
 * @param channelConfig：声道数
 * @param audioFormat： 采样位数.
 * See {@link AudioFormat#ENCODING_PCM_8BIT}, {@link AudioFormat#ENCODING_PCM_16BIT},
 * and {@link AudioFormat#ENCODING_PCM_FLOAT}.
 * @param bufferSizeInBytes： 音频录制的缓冲区大小
 * See {@link #getMinBufferSize(int, int, int)}
 * <p>
 * 获取AudioRecord所需的最小缓冲区大小
 * @param sampleRateInHz： 采样率
 * @param channelConfig：声道数
 * @param audioFormat： 采样位数.
 * <p>
 * 获取AudioRecord当前的录音状态
 * @param audioSource ：录音源
 * 这里选择使用麦克风：MediaRecorder.AudioSource.MIC
 * @param sampleRateInHz： 采样率
 * @param channelConfig：声道数
 * @param audioFormat： 采样位数.
 * See {@link AudioFormat#ENCODING_PCM_8BIT}, {@link AudioFormat#ENCODING_PCM_16BIT},
 * and {@link AudioFormat#ENCODING_PCM_FLOAT}.
 * @param bufferSizeInBytes： 音频录制的缓冲区大小
 * See {@link #getMinBufferSize(int, int, int)}
 * <p>
 * 获取AudioRecord所需的最小缓冲区大小
 * @param sampleRateInHz： 采样率
 * @param channelConfig：声道数
 * @param audioFormat： 采样位数.
 * <p>
 * 获取AudioRecord当前的录音状态
 * @param audioSource ：录音源
 * 这里选择使用麦克风：MediaRecorder.AudioSource.MIC
 * @param sampleRateInHz： 采样率
 * @param channelConfig：声道数
 * @param audioFormat： 采样位数.
 * See {@link AudioFormat#ENCODING_PCM_8BIT}, {@link AudioFormat#ENCODING_PCM_16BIT},
 * and {@link AudioFormat#ENCODING_PCM_FLOAT}.
 * @param bufferSizeInBytes： 音频录制的缓冲区大小
 * See {@link #getMinBufferSize(int, int, int)}
 * <p>
 * 获取AudioRecord所需的最小缓冲区大小
 * @param sampleRateInHz： 采样率
 * @param channelConfig：声道数
 * @param audioFormat： 采样位数.
 * <p>
 * 获取AudioRecord当前的录音状态
 * @param audioSource ：录音源
 * 这里选择使用麦克风：MediaRecorder.AudioSource.MIC
 * @param sampleRateInHz： 采样率
 * @param channelConfig：声道数
 * @param audioFormat： 采样位数.
 * See {@link AudioFormat#ENCODING_PCM_8BIT}, {@link AudioFormat#ENCODING_PCM_16BIT},
 * and {@link AudioFormat#ENCODING_PCM_FLOAT}.
 * @param bufferSizeInBytes： 音频录制的缓冲区大小
 * See {@link #getMinBufferSize(int, int, int)}
 * <p>
 * 获取AudioRecord所需的最小缓冲区大小
 * @param sampleRateInHz： 采样率
 * @param channelConfig：声道数
 * @param audioFormat： 采样位数.
 * <p>
 * 获取AudioRecord当前的录音状态
 * @param audioSource ：录音源
 * 这里选择使用麦克风：MediaRecorder.AudioSource.MIC
 * @param sampleRateInHz： 采样率
 * @param channelConfig：声道数
 * @param audioFormat： 采样位数.
 * See {@link AudioFormat#ENCODING_PCM_8BIT}, {@link AudioFormat#ENCODING_PCM_16BIT},
 * and {@link AudioFormat#ENCODING_PCM_FLOAT}.
 * @param bufferSizeInBytes： 音频录制的缓冲区大小
 * See {@link #getMinBufferSize(int, int, int)}
 * <p>
 * 获取AudioRecord所需的最小缓冲区大小
 * @param sampleRateInHz： 采样率
 * @param channelConfig：声道数
 * @param audioFormat： 采样位数.
 * <p>
 * 获取AudioRecord当前的录音状态
 * @param audioSource ：录音源
 * 这里选择使用麦克风：MediaRecorder.AudioSource.MIC
 * @param sampleRateInHz： 采样率
 * @param channelConfig：声道数
 * @param audioFormat： 采样位数.
 * See {@link AudioFormat#ENCODING_PCM_8BIT}, {@link AudioFormat#ENCODING_PCM_16BIT},
 * and {@link AudioFormat#ENCODING_PCM_FLOAT}.
 * @param bufferSizeInBytes： 音频录制的缓冲区大小
 * See {@link #getMinBufferSize(int, int, int)}
 * <p>
 * 获取AudioRecord所需的最小缓冲区大小
 * @param sampleRateInHz： 采样率
 * @param channelConfig：声道数
 * @param audioFormat： 采样位数.
 * <p>
 * 获取AudioRecord当前的录音状态
 * @param audioSource ：录音源
 * 这里选择使用麦克风：MediaRecorder.AudioSource.MIC
 * @param sampleRateInHz： 采样率
 * @param channelConfig：声道数
 * @param audioFormat： 采样位数.
 * See {@link AudioFormat#ENCODING_PCM_8BIT}, {@link AudioFormat#ENCODING_PCM_16BIT},
 * and {@link AudioFormat#ENCODING_PCM_FLOAT}.
 * @param bufferSizeInBytes： 音频录制的缓冲区大小
 * See {@link #getMinBufferSize(int, int, int)}
 * <p>
 * 获取AudioRecord所需的最小缓冲区大小
 * @param sampleRateInHz： 采样率
 * @param channelConfig：声道数
 * @param audioFormat： 采样位数.
 * <p>
 * 获取AudioRecord当前的录音状态
 * @param audioSource ：录音源
 * 这里选择使用麦克风：MediaRecorder.AudioSource.MIC
 * @param sampleRateInHz： 采样率
 * @param channelConfig：声道数
 * @param audioFormat： 采样位数.
 * See {@link AudioFormat#ENCODING_PCM_8BIT}, {@link AudioFormat#ENCODING_PCM_16BIT},
 * and {@link AudioFormat#ENCODING_PCM_FLOAT}.
 * @param bufferSizeInBytes： 音频录制的缓冲区大小
 * See {@link #getMinBufferSize(int, int, int)}
 * <p>
 * 获取AudioRecord所需的最小缓冲区大小
 * @param sampleRateInHz： 采样率
 * @param channelConfig：声道数
 * @param audioFormat： 采样位数.
 * <p>
 * 获取AudioRecord当前的录音状态
 * @param audioSource ：录音源
 * 这里选择使用麦克风：MediaRecorder.AudioSource.MIC
 * @param sampleRateInHz： 采样率
 * @param channelConfig：声道数
 * @param audioFormat： 采样位数.
 * See {@link AudioFormat#ENCODING_PCM_8BIT}, {@link AudioFormat#ENCODING_PCM_16BIT},
 * and {@link AudioFormat#ENCODING_PCM_FLOAT}.
 * @param bufferSizeInBytes： 音频录制的缓冲区大小
 * See {@link #getMinBufferSize(int, int, int)}
 * <p>
 * 获取AudioRecord所需的最小缓冲区大小
 * @param sampleRateInHz： 采样率
 * @param channelConfig：声道数
 * @param audioFormat： 采样位数.
 * <p>
 * 获取AudioRecord当前的录音状态
 * @param audioSource ：录音源
 * 这里选择使用麦克风：MediaRecorder.AudioSource.MIC
 * @param sampleRateInHz： 采样率
 * @param channelConfig：声道数
 * @param audioFormat： 采样位数.
 * See {@link AudioFormat#ENCODING_PCM_8BIT}, {@link AudioFormat#ENCODING_PCM_16BIT},
 * and {@link AudioFormat#ENCODING_PCM_FLOAT}.
 * @param bufferSizeInBytes： 音频录制的缓冲区大小
 * See {@link #getMinBufferSize(int, int, int)}
 * <p>
 * 获取AudioRecord所需的最小缓冲区大小
 * @param sampleRateInHz： 采样率
 * @param channelConfig：声道数
 * @param audioFormat： 采样位数.
 * <p>
 * 获取AudioRecord当前的录音状态
 * @param audioSource ：录音源
 * 这里选择使用麦克风：MediaRecorder.AudioSource.MIC
 * @param sampleRateInHz： 采样率
 * @param channelConfig：声道数
 * @param audioFormat： 采样位数.
 * See {@link AudioFormat#ENCODING_PCM_8BIT}, {@link AudioFormat#ENCODING_PCM_16BIT},
 * and {@link AudioFormat#ENCODING_PCM_FLOAT}.
 * @param bufferSizeInBytes： 音频录制的缓冲区大小
 * See {@link #getMinBufferSize(int, int, int)}
 * <p>
 * 获取AudioRecord所需的最小缓冲区大小
 * @param sampleRateInHz： 采样率
 * @param channelConfig：声道数
 * @param audioFormat： 采样位数.
 * <p>
 * 获取AudioRecord当前的录音状态
 * @param audioSource ：录音源
 * 这里选择使用麦克风：MediaRecorder.AudioSource.MIC
 * @param sampleRateInHz： 采样率
 * @param channelConfig：声道数
 * @param audioFormat： 采样位数.
 * See {@link AudioFormat#ENCODING_PCM_8BIT}, {@link AudioFormat#ENCODING_PCM_16BIT},
 * and {@link AudioFormat#ENCODING_PCM_FLOAT}.
 * @param bufferSizeInBytes： 音频录制的缓冲区大小
 * See {@link #getMinBufferSize(int, int, int)}
 * <p>
 * 获取AudioRecord所需的最小缓冲区大小
 * @param sampleRateInHz： 采样率
 * @param channelConfig：声道数
 * @param audioFormat： 采样位数.
 * <p>
 * 获取AudioRecord当前的录音状态
 * @param audioData 音频数据写入的byte[]缓冲区
 * @param offsetInBytes 偏移量
 * @param sizeInBytes 读取大小
 * @return 返回负数则表示读取失败
 * see {@link #ERROR_INVALID_OPERATION} -3 ： 初始化错误
 * {@link #ERROR_BAD_VALUE}  -3： 参数错误
 * {@link #ERROR_DEAD_OBJECT} -6：
 * {@link #ERROR}
 * @see AudioRecord#RECORDSTATE_STOPPED
 * @see AudioRecord#RECORDSTATE_RECORDING
 * <p>
 * 开始录制
 * <p>
 * 停止录制
 * @see AudioRecord#RECORDSTATE_STOPPED
 * @see AudioRecord#RECORDSTATE_RECORDING
 * <p>
 * 开始录制
 * <p>
 * 停止录制
 * @see AudioRecord#RECORDSTATE_STOPPED
 * @see AudioRecord#RECORDSTATE_RECORDING
 * <p>
 * 开始录制
 * <p>
 * 停止录制
 * @see AudioRecord#RECORDSTATE_STOPPED
 * @see AudioRecord#RECORDSTATE_RECORDING
 * <p>
 * 开始录制
 * <p>
 * 停止录制
 * @see AudioRecord#RECORDSTATE_STOPPED
 * @see AudioRecord#RECORDSTATE_RECORDING
 * <p>
 * 开始录制
 * <p>
 * 停止录制
 * @see AudioRecord#RECORDSTATE_STOPPED
 * @see AudioRecord#RECORDSTATE_RECORDING
 * <p>
 * 开始录制
 * <p>
 * 停止录制
 * @see AudioRecord#RECORDSTATE_STOPPED
 * @see AudioRecord#RECORDSTATE_RECORDING
 * <p>
 * 开始录制
 * <p>
 * 停止录制
 * @see AudioRecord#RECORDSTATE_STOPPED
 * @see AudioRecord#RECORDSTATE_RECORDING
 * <p>
 * 开始录制
 * <p>
 * 停止录制
 * @see AudioRecord#RECORDSTATE_STOPPED
 * @see AudioRecord#RECORDSTATE_RECORDING
 * <p>
 * 开始录制
 * <p>
 * 停止录制
 * @see AudioRecord#RECORDSTATE_STOPPED
 * @see AudioRecord#RECORDSTATE_RECORDING
 * <p>
 * 开始录制
 * <p>
 * 停止录制
 * @see AudioRecord#RECORDSTATE_STOPPED
 * @see AudioRecord#RECORDSTATE_RECORDING
 * <p>
 * 开始录制
 * <p>
 * 停止录制
 * @see AudioRecord#RECORDSTATE_STOPPED
 * @see AudioRecord#RECORDSTATE_RECORDING
 * <p>
 * 开始录制
 * <p>
 * 停止录制
 * @see AudioRecord#RECORDSTATE_STOPPED
 * @see AudioRecord#RECORDSTATE_RECORDING
 * <p>
 * 开始录制
 * <p>
 * 停止录制
 * @see AudioRecord#RECORDSTATE_STOPPED
 * @see AudioRecord#RECORDSTATE_RECORDING
 * <p>
 * 开始录制
 * <p>
 * 停止录制
 * @see AudioRecord#RECORDSTATE_STOPPED
 * @see AudioRecord#RECORDSTATE_RECORDING
 * <p>
 * 开始录制
 * <p>
 * 停止录制
 * @see AudioRecord#RECORDSTATE_STOPPED
 * @see AudioRecord#RECORDSTATE_RECORDING
 * <p>
 * 开始录制
 * <p>
 * 停止录制
 * @see AudioRecord#RECORDSTATE_STOPPED
 * @see AudioRecord#RECORDSTATE_RECORDING
 * <p>
 * 开始录制
 * <p>
 * 停止录制
 * @see AudioRecord#RECORDSTATE_STOPPED
 * @see AudioRecord#RECORDSTATE_RECORDING
 * <p>
 * 开始录制
 * <p>
 * 停止录制
 * @see AudioRecord#RECORDSTATE_STOPPED
 * @see AudioRecord#RECORDSTATE_RECORDING
 * <p>
 * 开始录制
 * <p>
 * 停止录制
 * @see AudioRecord#RECORDSTATE_STOPPED
 * @see AudioRecord#RECORDSTATE_RECORDING
 * <p>
 * 开始录制
 * <p>
 * 停止录制
 * @see AudioRecord#RECORDSTATE_STOPPED
 * @see AudioRecord#RECORDSTATE_RECORDING
 * <p>
 * 开始录制
 * <p>
 * 停止录制
 * @see AudioRecord#RECORDSTATE_STOPPED
 * @see AudioRecord#RECORDSTATE_RECORDING
 * <p>
 * 开始录制
 * <p>
 * 停止录制
 * @see AudioRecord#RECORDSTATE_STOPPED
 * @see AudioRecord#RECORDSTATE_RECORDING
 * <p>
 * 开始录制
 * <p>
 * 停止录制
 * @see AudioRecord#RECORDSTATE_STOPPED
 * @see AudioRecord#RECORDSTATE_RECORDING
 * <p>
 * 开始录制
 * <p>
 * 停止录制
 * @see AudioRecord#RECORDSTATE_STOPPED
 * @see AudioRecord#RECORDSTATE_RECORDING
 * <p>
 * 开始录制
 * <p>
 * 停止录制
 * @see AudioRecord#RECORDSTATE_STOPPED
 * @see AudioRecord#RECORDSTATE_RECORDING
 * <p>
 * 开始录制
 * <p>
 * 停止录制
 * @see AudioRecord#RECORDSTATE_STOPPED
 * @see AudioRecord#RECORDSTATE_RECORDING
 * <p>
 * 开始录制
 * <p>
 * 停止录制
 * @see AudioRecord#RECORDSTATE_STOPPED
 * @see AudioRecord#RECORDSTATE_RECORDING
 * <p>
 * 开始录制
 * <p>
 * 停止录制
 * @see AudioRecord#RECORDSTATE_STOPPED
 * @see AudioRecord#RECORDSTATE_RECORDING
 * <p>
 * 开始录制
 * <p>
 * 停止录制
 * @see AudioRecord#RECORDSTATE_STOPPED
 * @see AudioRecord#RECORDSTATE_RECORDING
 * <p>
 * 开始录制
 * <p>
 * 停止录制
 * @see AudioRecord#RECORDSTATE_STOPPED
 * @see AudioRecord#RECORDSTATE_RECORDING
 * <p>
 * 开始录制
 * <p>
 * 停止录制
 * @see AudioRecord#RECORDSTATE_STOPPED
 * @see AudioRecord#RECORDSTATE_RECORDING
 * <p>
 * 开始录制
 * <p>
 * 停止录制
 * @see AudioRecord#RECORDSTATE_STOPPED
 * @see AudioRecord#RECORDSTATE_RECORDING
 * <p>
 * 开始录制
 * <p>
 * 停止录制
 * <p>
 * 从录音设备中读取音频数据
 */
//AudioRecord构造函数：
/**
 * @param audioSource ：录音源
 * 这里选择使用麦克风：MediaRecorder.AudioSource.MIC
 * @param sampleRateInHz： 采样率
 * @param channelConfig：声道数
 * @param audioFormat： 采样位数.
 *   See {@link AudioFormat#ENCODING_PCM_8BIT}, {@link AudioFormat#ENCODING_PCM_16BIT},
 *   and {@link AudioFormat#ENCODING_PCM_FLOAT}.
 * @param bufferSizeInBytes： 音频录制的缓冲区大小
 *   See {@link #getMinBufferSize(int, int, int)}
 */
//public AudioRecord(int audioSource, int sampleRateInHz, int channelConfig, int audioFormat,
//        int bufferSizeInBytes)
/**
 * 获取AudioRecord所需的最小缓冲区大小
 * @param sampleRateInHz： 采样率
 * @param channelConfig：声道数
 * @param audioFormat： 采样位数.
 */
//public static int getMinBufferSize (int sampleRateInHz,
//        int channelConfig,
//        int audioFormat)
/**
 * 获取AudioRecord当前的录音状态
 *   @see AudioRecord#RECORDSTATE_STOPPED
 *   @see AudioRecord#RECORDSTATE_RECORDING
 */
//public int getRecordingState()
/**
 * 开始录制
 */
//public int startRecording()
/**
 * 停止录制
 */
//public int stop()


/**
 * 从录音设备中读取音频数据
 * @param audioData 音频数据写入的byte[]缓冲区
 * @param offsetInBytes 偏移量
 * @param sizeInBytes 读取大小
 * @return 返回负数则表示读取失败
 *      see {@link #ERROR_INVALID_OPERATION} -3 ： 初始化错误
{@link #ERROR_BAD_VALUE}  -3： 参数错误
{@link #ERROR_DEAD_OBJECT} -6：
{@link #ERROR}
 */
//public int read(@NonNull byte[] audioData, int offsetInBytes, int sizeInBytes)

import android.media.AudioFormat;
import android.media.AudioRecord;
import android.media.MediaRecorder;
import android.os.Environment;
import android.os.Handler;
import android.os.Looper;
import android.text.TextUtils;
import android.util.Log;

import com.pwj.record.ui.video.fftlib.ByteUtils;
import com.pwj.record.ui.video.fftlib.FftFactory;
import com.pwj.record.ui.video.utils.RecordFileUtils;
import com.pwj.record.ui.video.utils.WavUtils;
import com.pwj.record.utils.log.ZLog;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.Serializable;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;


public class RecordHelper {
    private static final String TAG = "RecordHelper";
    private static final int RECORD_AUDIO_BUFFER_TIMES = 1;
    private volatile static RecordHelper instance;

    //0.此状态用于控制线程中的循环操作，应用volatile修饰，保持数据的一致性
    private volatile RecordState state = RecordState.IDLE;

    private RecordStateListener recordStateListener;
    private RecordDataListener recordDataListener;
    private RecordSoundSizeListener recordSoundSizeListener;
    private RecordResultListener recordResultListener;
    private RecordFftDataListener recordFftDataListener;
    private RecordConfig currentConfig;
    private AudioRecordThread audioRecordThread;
    private Handler mainHandler = new Handler(Looper.getMainLooper());

    private File resultFile = null;
    private File tempFile = null;
    private List<File> files = new ArrayList<>();
    private Mp3EncodeThread mp3EncodeThread;


    private RecordHelper() {
    }

    static RecordHelper getInstance() {
        if (instance == null) {
            synchronized (RecordHelper.class) {
                if (instance == null) {
                    instance = new RecordHelper();
                }
            }
        }
        return instance;
    }

    public RecordState getState() {
        return state;
    }

    public void start(String filePath, RecordConfig config) {
        currentConfig = config;
        if (state != RecordState.IDLE && state != RecordState.STOP) {
            ZLog.e(TAG, String.format("状态异常当前状态： %s", state.name()));
            return;
        }
        resultFile = new File(filePath);
        String tempFilePath = getTempFilePath();

        ZLog.e(TAG, String.format("----------------开始录制 %s------------------------", currentConfig.getFormat().name()));
        ZLog.e(TAG, String.format("参数： %s", currentConfig.toString()));
        ZLog.e(TAG, String.format("pcm缓存 tmpFile: %s", tempFilePath));
        ZLog.e(TAG, String.format("录音文件 resultFile: %s", filePath));

        tempFile = new File(tempFilePath);
        audioRecordThread = new AudioRecordThread();
        audioRecordThread.start();
    }

    public void resume() {
        if (state != RecordState.PAUSE) {
            ZLog.e(TAG, String.format("状态异常当前状态： %s", state.name()));
            return;
        }

        String tempFilePath = getTempFilePath();
        ZLog.e(TAG, String.format("tmpPCM File: %s", tempFilePath));
        tempFile = new File(tempFilePath);
        audioRecordThread = new AudioRecordThread();
        audioRecordThread.start();
    }

    public void pause() {
        if (state != RecordState.RECORDING) {
            ZLog.e(TAG, String.format("状态异常当前状态： %s", state.name()));
            return;
        }
        state = RecordState.PAUSE;
        notifyState();
    }

    public void stop() {
        if (state == RecordState.IDLE) {
            ZLog.e(TAG, String.format("状态异常当前状态： %s", state.name()));
            return;
        }

        if (state == RecordState.PAUSE) {
            makeFile();
            state = RecordState.IDLE;
            notifyState();
            stopMp3Encoder();
        } else {
            state = RecordState.STOP;
            notifyState();
        }
    }

    private void stopMp3Encoder() {
        if (mp3EncodeThread != null) {
            mp3EncodeThread.stopSafe(new EncordFinishListener() {
                @Override
                public void onFinish() {
                    notifyFinish();
                    mp3EncodeThread = null;
                }
            });
        } else {
            ZLog.e(TAG, "mp3EncodeThread is null, 代码业务流程有误，请检查！！ ");
        }
    }

    private void notifyState() {
        if (recordStateListener == null) {
            return;
        }
        mainHandler.post(new Runnable() {
            @Override
            public void run() {
                recordStateListener.onStateChange(state);
            }
        });
        if (state == RecordState.STOP || state == RecordState.PAUSE) {
            if (recordSoundSizeListener != null) {
                recordSoundSizeListener.onSoundSize(0);
            }
        }
    }

    private void notifyFinish() {
        ZLog.e(TAG, String.format("录音结束 file: %s", resultFile.getAbsolutePath()));
        mainHandler.post(new Runnable() {
            @Override
            public void run() {
                if (recordStateListener != null) {
                    recordStateListener.onStateChange(RecordState.FINISH);
                }
                if (recordResultListener != null) {
                    recordResultListener.onResult(resultFile);
                }
            }
        });
    }

    private void notifyError(final String error) {
        if (recordStateListener == null) {
            return;
        }
        mainHandler.post(new Runnable() {
            @Override
            public void run() {
                recordStateListener.onError(error);
            }
        });
    }

    /**
     * 根据当前的时间生成相应的文件名
     * 实例 record_20160101_13_15_12
     */
    private String getTempFilePath() {
        if (TextUtils.isEmpty(currentConfig.getRecordDir())) {
            String fileDir = String.format(Locale.getDefault(), "%s/Record/", Environment.getExternalStorageDirectory().getAbsolutePath());
            if (!RecordFileUtils.createOrExistsDir(fileDir)) {
                ZLog.e(TAG, String.format("文件夹创建失败：%s", fileDir));
            }
            String fileName = String.format(Locale.getDefault(), "record_tmp_%s", RecordFileUtils.getNowString(new SimpleDateFormat("yyyyMMdd_HH_mm_ss", Locale.SIMPLIFIED_CHINESE)));
            return String.format(Locale.getDefault(), "%s%s.pcm", fileDir, fileName);
        } else {
            if (!RecordFileUtils.createOrExistsDir(currentConfig.getRecordDir())) {
                ZLog.e(TAG, String.format("文件夹创建失败：%s", currentConfig.getRecordDir()));
            }
            String fileName = String.format(Locale.getDefault(), "record_tmp_%s", RecordFileUtils.getNowString(new SimpleDateFormat("yyyyMMdd_HH_mm_ss", Locale.SIMPLIFIED_CHINESE)));
            return String.format(Locale.getDefault(), "%s%s.pcm", currentConfig.getRecordDir(), fileName);
        }
    }

    private class AudioRecordThread extends Thread {
        private AudioRecord audioRecord;
        private int bufferSize;

        public AudioRecordThread() {
            if(audioRecord == null){
                bufferSize = AudioRecord.getMinBufferSize(currentConfig.getSampleRate(),
                        currentConfig.getChannelConfig(), currentConfig.getEncodingConfig()) * RECORD_AUDIO_BUFFER_TIMES;
                ZLog.e(TAG, "record buffer size = " + bufferSize);
                audioRecord = new AudioRecord(MediaRecorder.AudioSource.MIC, currentConfig.getSampleRate(),
                        currentConfig.getChannelConfig(), currentConfig.getEncodingConfig(), bufferSize);
            }

            if (currentConfig.getFormat() == RecordFormat.MP3) {
                if (mp3EncodeThread == null) {
                    initMp3EncoderThread(bufferSize);
                } else {
                    ZLog.e(TAG, "mp3EncodeThread != null, 请检查代码");
                }
            }
        }

        private void initMp3EncoderThread(int bufferSize) {
            try {
                mp3EncodeThread = new Mp3EncodeThread(resultFile, bufferSize);
                mp3EncodeThread.start();
            } catch (Exception e) {
                ZLog.e(TAG, e.getMessage());
            }
        }

        @Override
        public void run() {
            super.run();
            switch (currentConfig.getFormat()) {
                case MP3:
                    startMp3Recorder();
                    break;
                default:
                    startPcmRecorder();
                    break;
            }
        }

        private void startPcmRecorder() {
            state = RecordState.RECORDING;
            notifyState();
            ZLog.e(TAG, "开始录制 Pcm");
            FileOutputStream fos = null;
            try {
                fos = new FileOutputStream(tempFile);
                audioRecord.startRecording();
                byte[] byteBuffer = new byte[bufferSize];

                while (state == RecordState.RECORDING) {
                    int end = audioRecord.read(byteBuffer, 0, byteBuffer.length);
                    notifyData(byteBuffer);
                    fos.write(byteBuffer, 0, end);
                    fos.flush();
                }
                audioRecord.stop();
                files.add(tempFile);
                if (state == RecordState.STOP) {
                    makeFile();
                } else {
                    ZLog.e(TAG, "暂停！");
                }
            } catch (Exception e) {
                ZLog.e(TAG, e.getMessage());
                notifyError("录音失败");
            } finally {
                try {
                    if (fos != null) {
                        fos.close();
                    }
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            if (state != RecordState.PAUSE) {
                state = RecordState.IDLE;
                notifyState();
                ZLog.e(TAG, "录音结束");
            }
        }

        private void startMp3Recorder() {
            state = RecordState.RECORDING;
            notifyState();

            try {
                audioRecord.startRecording();
                short[] byteBuffer = new short[bufferSize];

                while (state == RecordState.RECORDING) {
                    int end = audioRecord.read(byteBuffer, 0, byteBuffer.length);
                    if (mp3EncodeThread != null) {
                        mp3EncodeThread.addChangeBuffer(new ChangeBuffer(byteBuffer, end));
                    }
                    notifyData(ByteUtils.toBytes(byteBuffer));
                }
                audioRecord.stop();
            } catch (Exception e) {
                ZLog.e(TAG, e.getMessage());
                notifyError("录音失败");
            }
            if (state != RecordState.PAUSE) {
                state = RecordState.IDLE;
                notifyState();
                stopMp3Encoder();
            } else {
                ZLog.e(TAG, "暂停");
            }

        }
    }

//    FFT频谱图
    private FftFactory fftFactory = new FftFactory(FftFactory.Level.Original);
    private void notifyData(byte[] data) {
        if (recordDataListener == null && recordSoundSizeListener == null && recordFftDataListener == null) {
            return;
        }
        mainHandler.post(new Runnable() {
            @Override
            public void run() {
                if (recordDataListener != null) {
                    recordDataListener.onData(data);
                }

                if (recordFftDataListener != null || recordSoundSizeListener != null) {
                    byte[] fftData = fftFactory.makeFftData(data);
                    if (fftData != null) {
                        if (recordSoundSizeListener != null) {
                            recordSoundSizeListener.onSoundSize(getDb(fftData));
                        }
                        if (recordFftDataListener != null) {
                            recordFftDataListener.onFftData(fftData);
                        }
                    }
                }
            }
        });
    }

    private int getDb(byte[] data) {
        double sum = 0;
        double ave;
        int length = data.length > 128 ? 128 : data.length;
        int offsetStart = 8;
        for (int i = offsetStart; i < length; i++) {
            sum += data[i];
        }
        ave = (sum / (length - offsetStart)) * 65536 / 128f;
        int i = (int) (Math.log10(ave) * 20);
        return i < 0 ? 27 : i;
    }

    public class Mp3EncodeThread extends Thread {
        private String TAG = Mp3EncodeThread.class.getSimpleName();
        private List<ChangeBuffer> cacheBufferList = Collections.synchronizedList(new LinkedList<ChangeBuffer>());
        private File file;
        private FileOutputStream os;
        private byte[] mp3Buffer;
        private EncordFinishListener encordFinishListener;
        /**
         * 是否已停止录音
         */
        private volatile boolean isOver = false;

        /**
         * 是否继续轮询数据队列
         */
        private volatile boolean start = true;

        public Mp3EncodeThread(File file, int bufferSize) {
            this.file = file;
            mp3Buffer = new byte[(int) (7200 + (bufferSize * 2 * 1.25))];
            RecordConfig currentConfig = RecordService.getCurrentConfig();
            int sampleRate = currentConfig.getSampleRate();

            Log.w(TAG, String.format("in_sampleRate:%s，getChannelCount:%s ，out_sampleRate：%s 位宽： %s,",
                    sampleRate, currentConfig.getChannelCount(), sampleRate, currentConfig.getRealEncoding()));
            Mp3Encoder.init(sampleRate, currentConfig.getChannelCount(), sampleRate, currentConfig.getRealEncoding());
        }

        @Override
        public void run() {
            try {
                this.os = new FileOutputStream(file);
            } catch (FileNotFoundException e) {
                Log.e(TAG, e.getMessage());
                return;
            }

            while (start) {
                ChangeBuffer next = next();
                Log.v(TAG, String.format("处理数据：%s", next == null ? "null" : next.getReadSize()));
                lameData(next);
            }
        }

        public void addChangeBuffer(ChangeBuffer changeBuffer) {
            if (changeBuffer != null) {
                cacheBufferList.add(changeBuffer);
                synchronized (this) {
                    notify();
                }
            }
        }

        public void stopSafe(EncordFinishListener encordFinishListener) {
            this.encordFinishListener = encordFinishListener;
            isOver = true;
            synchronized (this) {
                notify();
            }
        }

        private ChangeBuffer next() {
            for (; ; ) {
                if (cacheBufferList == null || cacheBufferList.size() == 0) {
                    try {
                        if (isOver) {
                            finish();
                        }
                        synchronized (this) {
                            wait();
                        }
                    } catch (Exception e) {
                        Log.e(TAG, e.getMessage());
                    }
                } else {
                    return cacheBufferList.remove(0);
                }
            }
        }

        private void lameData(ChangeBuffer changeBuffer) {
            if (changeBuffer == null) {
                return;
            }
            short[] buffer = changeBuffer.getData();
            int readSize = changeBuffer.getReadSize();
            if (readSize > 0) {
                int encodedSize = Mp3Encoder.encode(buffer, buffer, readSize, mp3Buffer);
                if (encodedSize < 0) {
                    Log.e(TAG, "Lame encoded size: " + encodedSize);
                }
                try {
                    os.write(mp3Buffer, 0, encodedSize);
                } catch (IOException e) {
                    Log.e(TAG, "Unable to write to file");
                }
            }
        }

        private void finish() {
            start = false;
            final int flushResult = Mp3Encoder.flush(mp3Buffer);
            if (flushResult > 0) {
                try {
                    os.write(mp3Buffer, 0, flushResult);
                    os.close();
                } catch (final IOException e) {
                    Log.e(TAG, e.getMessage());
                }
            }
            Log.d(TAG, String.format("转换结束 :%s", file.length()));
            if (encordFinishListener != null) {
                encordFinishListener.onFinish();
            }
        }

    }

    public static class ChangeBuffer {
        private short[] rawData;
        private int readSize;

        public ChangeBuffer(short[] rawData, int readSize) {
            this.rawData = rawData.clone();
            this.readSize = readSize;
        }

        short[] getData() {
            return rawData;
        }

        int getReadSize() {
            return readSize;
        }
    }

    private void makeFile() {
        switch (currentConfig.getFormat()) {
            case MP3:
                return;
            case WAV:
                mergePcmFile();
                makeWav();
                break;
            case PCM:
                mergePcmFile();
                break;
            default:
                break;
        }
        notifyFinish();
        ZLog.e(TAG, String.format("录音完成！ path: %s ； 大小：%s", resultFile.getAbsoluteFile(), resultFile.length()));
    }

    /**
     * 添加mav头文件
     */
    private void makeWav() {
        if (!RecordFileUtils.isFile(resultFile) || resultFile.length() > 0) return;

        byte[] header = WavUtils.generateWavFileHeader((int) resultFile.length(), currentConfig.getSampleRate(), currentConfig.getChannelCount(), currentConfig.getEncoding());
        WavUtils.writeHeader(resultFile, header);
//        WavUtils.pcmToWav(resultFile,header);
    }

    /**
     * 合并文件
     */
    private void mergePcmFile() {
        boolean mergeSuccess = mergePcmFiles(resultFile, files);
        if (mergeSuccess) {
            notifyError("合并失败");
        }
    }

    /**
     * 合并Pcm文件
     *
     * @param recordFile 输出文件
     * @param files      多个文件源
     * @return 是否成功
     */
    private boolean mergePcmFiles(File recordFile, List<File> files) {
        if (recordFile == null || files == null || files.size() <= 0) {
            return false;
        }

        FileOutputStream fos = null;
        BufferedOutputStream bos = null;
        byte[] buffer = new byte[1024];
        try {
            fos = new FileOutputStream(recordFile);
            bos = new BufferedOutputStream(fos);

            for (int i = 0; i < files.size(); i++) {
                BufferedInputStream bis = new BufferedInputStream(new FileInputStream(files.get(i)));
                int readCount;
                while ((readCount = bis.read(buffer)) > 0) {
                    bos.write(buffer, 0, readCount);
                }
                bis.close();
            }
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        } finally {
            try {
                if (bos != null) {
                    bos.close();
                }
                if (fos != null) {
                    fos.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        for (int i = 0; i < files.size(); i++) {
            files.get(i).delete();
        }
        files.clear();
        return true;


    }


    /**
     * 音频设置
     */
    public static class RecordConfig implements Serializable {
        /**
         * 录音格式 默认WAV格式
         */
        private RecordFormat format = RecordFormat.WAV;
        /**
         * 通道数:默认单通道
         */
        private int channelConfig = AudioFormat.CHANNEL_IN_MONO;

        /**
         * 位宽
         */
        private int encodingConfig = AudioFormat.ENCODING_PCM_16BIT;

        /**
         * 采样率
         */
        private int sampleRate = 16000;

        /*
         * 录音文件存放路径，默认sdcard/Record
         */
        private String recordDir = String.format(Locale.getDefault(),
                "%s/Record/",
                Environment.getExternalStorageDirectory().getAbsolutePath());

        public RecordConfig() {
        }

        public RecordConfig(RecordFormat format) {
            this.format = format;
        }

        /**
         * @param format         录音文件的格式
         * @param channelConfig  声道配置
         *                       单声道：See {@link AudioFormat#CHANNEL_IN_MONO}
         *                       双声道：See {@link AudioFormat#CHANNEL_IN_STEREO}
         * @param encodingConfig 位宽配置
         *                       8Bit： See {@link AudioFormat#ENCODING_PCM_8BIT}
         *                       16Bit: See {@link AudioFormat#ENCODING_PCM_16BIT},
         * @param sampleRate     采样率 hz: 8000/16000/44100
         */
        public RecordConfig(RecordFormat format, int channelConfig, int encodingConfig, int sampleRate) {
            this.format = format;
            this.channelConfig = channelConfig;
            this.encodingConfig = encodingConfig;
            this.sampleRate = sampleRate;
        }


        public String getRecordDir() {
            return recordDir;
        }

        public void setRecordDir(String recordDir) {
            this.recordDir = recordDir;
        }

        /**
         * 获取当前录音的采样位宽 单位bit
         *
         * @return 采样位宽 0: error
         */
        public int getEncoding() {
            if (format == RecordFormat.MP3) {//mp3后期转换
                return 16;
            }

            if (encodingConfig == AudioFormat.ENCODING_PCM_8BIT) {
                return 8;
            } else if (encodingConfig == AudioFormat.ENCODING_PCM_16BIT) {
                return 16;
            } else {
                return 0;
            }
        }

        /**
         * 获取当前录音的采样位宽 单位bit
         *
         * @return 采样位宽 0: error
         */
        public int getRealEncoding() {
            if (encodingConfig == AudioFormat.ENCODING_PCM_8BIT) {
                return 8;
            } else if (encodingConfig == AudioFormat.ENCODING_PCM_16BIT) {
                return 16;
            } else {
                return 0;
            }
        }

        /**
         * 当前的声道数
         *
         * @return 声道数： 0：error
         */
        public int getChannelCount() {
            if (channelConfig == AudioFormat.CHANNEL_IN_MONO) {
                return 1;
            } else if (channelConfig == AudioFormat.CHANNEL_IN_STEREO) {
                return 2;
            } else {
                return 0;
            }
        }

        //get&set

        public RecordFormat getFormat() {
            return format;
        }

        public RecordConfig setFormat(RecordFormat format) {
            this.format = format;
            return this;
        }

        public int getChannelConfig() {
            return channelConfig;
        }

        public RecordConfig setChannelConfig(int channelConfig) {
            this.channelConfig = channelConfig;
            return this;
        }

        public int getEncodingConfig() {
            if (format == RecordFormat.MP3) {//mp3后期转换
                return AudioFormat.ENCODING_PCM_16BIT;
            }
            return encodingConfig;
        }

        public RecordConfig setEncodingConfig(int encodingConfig) {
            this.encodingConfig = encodingConfig;
            return this;
        }

        public int getSampleRate() {
            return sampleRate;
        }

        public RecordConfig setSampleRate(int sampleRate) {
            this.sampleRate = sampleRate;
            return this;
        }


        @Override
        public String toString() {
            return String.format(Locale.getDefault(), "录制格式： %s,采样率：%sHz,位宽：%s bit,声道数：%s", format, sampleRate, getEncoding(), getChannelCount());
        }
    }

    public enum RecordFormat {
        /**
         * mp3格式
         */
        MP3(".mp3"),
        /**
         * wav格式
         */
        WAV(".wav"),
        /**
         * pcm格式
         */
        PCM(".pcm");

        private String extension;

        public String getExtension() {
            return extension;
        }

        RecordFormat(String extension) {
            this.extension = extension;
        }
    }

    /**
     * 表示当前状态
     */
    public enum RecordState {
        /**
         * 空闲状态
         */
        IDLE,
        /**
         * 录音中
         */
        RECORDING,
        /**
         * 暂停中
         */
        PAUSE,
        /**
         * 正在停止
         */
        STOP,
        /**
         * 录音流程结束（转换结束）
         */
        FINISH
    }

    /*********************************************监听事件****************************************/
    public interface RecordDataListener {

        /**
         * 当前的录音状态发生变化
         *
         * @param data 当前音频数据
         */
        void onData(byte[] data);

    }

    public interface RecordFftDataListener {

        /**
         * @param data 录音可视化数据，即傅里叶转换后的数据：fftData
         */
        void onFftData(byte[] data);

    }

    public interface RecordResultListener {

        /**
         * 录音文件
         *
         * @param result 录音文件
         */
        void onResult(File result);
    }

    public interface RecordSoundSizeListener {

        /**
         * 实时返回音量大小
         *
         * @param soundSize 当前音量大小
         */
        void onSoundSize(int soundSize);

    }

    public interface RecordStateListener {

        /**
         * 当前的录音状态发生变化
         *
         * @param state 当前状态
         */
        void onStateChange(RecordHelper.RecordState state);

        /**
         * 录音错误
         *
         * @param error 错误
         */
        void onError(String error);

    }

    public void setRecordStateListener(RecordStateListener recordStateListener) {
        this.recordStateListener = recordStateListener;
    }

    public void setRecordDataListener(RecordDataListener recordDataListener) {
        this.recordDataListener = recordDataListener;
    }

    public void setRecordSoundSizeListener(RecordSoundSizeListener recordSoundSizeListener) {
        this.recordSoundSizeListener = recordSoundSizeListener;
    }

    public void setRecordResultListener(RecordResultListener recordResultListener) {
        this.recordResultListener = recordResultListener;
    }

    public void setRecordFftDataListener(RecordFftDataListener recordFftDataListener) {
        this.recordFftDataListener = recordFftDataListener;
    }

    public interface EncordFinishListener {
        /**
         * 格式转换完毕
         */
        void onFinish();
    }
}
